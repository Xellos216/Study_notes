# Day 3 - 복습 퀴즈 피드백 정리 (13305_feedback.md)

---

## ✅ Q1. `range(n-1)`를 사용하는 이유는 무엇인가요?

**사용자 답변**
> n은 도시의 갯수, 마지막 도시는 도착지니까 주유할 필요 없기 때문에 빼야한다.

**피드백**
- ✅ 정확함. 마지막 도시는 주유가 필요 없기 때문에 `range(n-1)`만큼 반복한다.

---

## ✅ Q2. `min_price = price[0]`은 어떤 역할을 하나요?

**사용자 답변**
> 다음 도시에 도착 했을 때 비교를 위해 처음 도시와 기름 값을 비교해주는 기준이 됌.

**피드백 및 보완**
- 약간의 오해 있음: 비교는 "도착 후"가 아니라 **도착 전 주유를 어디서 할지 정하는 기준**이다.
- "됌" → "됨"

**개선 답변**
> 처음 도시에서 출발할 때 무조건 주유해야 하므로, 그 가격을 기준으로 시작함. 이후 더 싼 주유소가 나오면 그때마다 갱신.

---

## ✅ Q3. `if price[i] < min_price:`를 사용하는 이유는?

**사용자 답변**
> 현재 도착지의 기름 값이 예전 도시의 기름 값보다 싸다면 여기서 주유해야 하기 때문에

**피드백 및 보완**
- 문장의 흐름이 조금 혼란스러움. 실제로는 "기름값 기준을 바꿀지 말지 판단하는 조건"임.

**개선 답변**
> 지금 도시의 주유 가격이 더 싸면, 앞으로는 이 가격을 기준으로 주유하는 게 유리하기 때문에 갱신하는 조건이다.

---

## ✅ Q4. `total += min_price * distance[i]` 구문은 어떤 의미인가요?

**사용자 답변**
> 현재 도시의 기름 값과 거리를 곱한 값을 더 해라.

**피드백 및 보완**
- "현재 도시의 가격"이 아니라 "가장 저렴했던 가격"

**개선 답변**
> 지금까지 중 가장 싼 주유 가격을 기준으로, 다음 도시까지의 거리만큼 기름을 주유하고 비용을 누적한다.

---

## ✅ Q5. 이 문제는 왜 그리디 알고리즘으로 풀 수 있나요?

**사용자 답변**
> 여러 경우의 수 중에 최소의 값을 나오게 해야하는 문제이므로 그리디임

**피드백 및 보완**
- 단순히 "최소값을 구하는 문제"가 아니라, **매 순간의 선택이 전체 최적을 만드는 구조**이기 때문에 그리디임

**개선 답변**
> 각 순간마다 가장 싼 주유소에서 주유하는 것이 전체 비용을 최소화시킬 수 있기 때문에, 그리디 알고리즘으로 해결할 수 있다.

---

## ✅ Q6. `price = list(map(int, input().split()))` 코드의 동작을 간단히 설명해보세요.

**사용자 답변**
> (빈칸)

**개선 답변**
> 한 줄로 공백으로 입력된 숫자들을 정수로 변환하여 리스트로 저장한다.
> 예: "5 2 4 1" → [5, 2, 4, 1]

---

## ✅ Q7. `min_price`가 현재보다 비싸도 바꾸지 않는 이유는 무엇인가요?

**사용자 답변**
> 반복문 안에 if price[i] < min_price가 있기 때문에

**피드백 및 보완**
- 조건이 있다는 걸 말하기보다는 "왜 바꾸지 않아도 되는가"를 설명해야 함

**개선 답변**
> 더 비싼 주유소에서는 주유할 필요가 없기 때문에, 기존의 더 싼 가격을 유지하고 그대로 사용한다.

---

## ✅ Q8. 실제 기름을 '가득 넣는지', '거리만큼 넣는지' 판단은 코드에서 어떻게 표현되나요?

**사용자 답변**
> (빈칸)

**개선 답변**
> `total += min_price * distance[i]`에서 거리만큼(min_price × 거리)만큼만 주유하는 방식으로 표현됨. 즉, 가득 넣는 게 아니라 다음 도시까지 갈 수 있는 만큼만 주유한다.

---

이 복습은 단순 이해를 넘어서 **문제의 구조와 알고리즘적 사고 방식까지 정립**하는 데 매우 중요합니다.

