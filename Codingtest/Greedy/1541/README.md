# Day 2 - 잃어버린 괄호 문제 Summary

## 📌 문제 유형

- **그리디 알고리즘(Greedy)**: 괄호를 적절히 묶어서 수식의 결과를 최소화
- **문자열 파싱 + 누적 합**을 활용한 계산 최적화 문제

## ✅ 핵심 아이디어

- 수식에서 `-` 연산자는 그 이후 수들을 한꺼번에 빼는 게 가장 이득
- 즉, **첫 번째 '-' 뒤에 나오는 모든 수를 괄호로 묶어서 한 번에 빼자**
- `55-50+40` → `55 - (50 + 40)`처럼 처리하면 최소값을 만들 수 있음

## 🔁 풀이 흐름 요약

1. 전체 수식을 문자열로 입력받음 (`input()`)
2. `'-'`를 기준으로 수식을 나눔 (`split('-')`)
3. 첫 번째 항은 따로 계산하여 `result`에 더함
4. 두 번째 항부터는 `+`를 기준으로 잘라 합산 후 `result`에서 뺌
5. 최종 결과 출력

## 💻 정답 코드 (Python)

```python
expression = input()
parts = expression.split('-')
result = 0

first_sum = sum(map(int, parts[0].split('+')))
result += first_sum

for part in parts[1:]:
    result -= sum(map(int, part.split('+')))

print(result)
```

## 🎯 외워야 할 것

| 키워드      | 설명                                          |
|-----------|---------------------------------------------|
| split()   | `split('-')`, `split('+')`로 수식 나누기            |
| map+sum   | `sum(map(int, ...))`으로 문자열 숫자 합 구하기      |
| 누적 연산   | `result += x`, `result -= y`로 계산 누적          |
| parts[1:] | 첫 항을 제외한 나머지 항들만 반복처리할 때 사용       |

## 🔍 시간 복잡도

- **문자열 파싱**: O(N) (N은 수식 길이)
- **합산 계산**: O(K) (K는 '+'로 나뉜 항의 수)
- **총 시간 복잡도**: O(N)

## 🧠 그리디 사고법 적용 요약

- 전체 식에서 최소값을 만들기 위해선 `-` 이후 항들을 가능한 많이 묶어야 함
- 이는 항상 최적의 해를 주므로 그리디 조건을 만족
- 즉, **괄호 없이도 괄호처럼 계산 흐름을 설계하는 전략**

