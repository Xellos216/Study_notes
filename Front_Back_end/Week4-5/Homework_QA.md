# Firebase 연동 코드 비교: 정상 작동 vs 비정상 작동

## ✅ 1. 공통 구조
- 모두 Firebase Firestore 사용
- `<script type="module">`로 Firebase SDK 9.x ES Module 방식 도입
- Firestore의 `collection()`, `getDocs()`, `addDoc()` 사용

---

## ✅ 2. 첫 번째 코드 (`나만의 추억 앨범`)
- **즉시 실행 async 함수 없음**: `await getDocs()`가 모듈 최상단에 위치
  - ✅ ES Module 스코프에서는 허용됨
- **버튼 클릭 이벤트**가 `$('#postingbtn').click()`로 DOM 렌더링 후 등록됨
- **입력값 필드의 id와 이벤트 핸들러가 일치** (예: `#image`, `#title`, `#content`, `#date`)
- **카드 append 대상(`id="card"`)이 명확히 존재**
- ✅ 결과적으로 Firebase에서 데이터 읽기/쓰기 모두 정상 작동

---

## ❌ 3. 두 번째 코드 (`푸드파이터`)
- **`async () => { ... }` 함수가 실행되지 않음**
  - ❌ 선언만 있고 즉시 실행하지 않아 `getDocs()`도 호출 안 됨
- **카드 출력 대상(`.row-cols-3`)에 id 없음**, 입력란과 혼동될 가능성 존재
- **이벤트 핸들러 내에서 HTML 요소 ID 불일치**
  - 예: `#floatingInput`, `#foodTitle`, `#floatingTextarea` → 코드에서는 `title_input`, `comment_input`로 예상
- **Firebase 설정 객체 미기입 상태**
- **카드 HTML 생성 로직(`tempHtml`)이 정의되지 않은 채 append만 호출됨**

---

## ✅ 4. 결론
| 항목 | 첫 번째 코드 | 두 번째 코드 |
|------|--------------|--------------|
| `await` 위치 | 모듈 최상단 허용 위치 | ❌ 실행되지 않는 함수식 |
| 카드 append 대상 | `id="card"` 존재 | ❌ 대상 명확하지 않음 |
| 이벤트 바인딩 | jQuery → DOM 렌더 후 실행 | ❌ 바인딩 전 DOM 로드 여부 불확실 |
| 필드 ID 일치 | ✅ 모두 일치 | ❌ 코드와 HTML 불일치 |
| Firebase 설정 | ✅ 존재 | ⚠ 미입력 상태 (주석처리됨) |
| 카드 출력 | 정상 출력 | 실패 |

---

## ✅ 5. 개선 팁
- 모듈 스코프에서는 `await` 사용 가능하지만 **즉시 실행 async 함수**로 감싸는 것이 안전
- 입력 필드의 `id`와 JS 코드가 반드시 **1:1 매칭**되어야 함
- `.append()` 대상은 **입력 form이 아닌, 카드 리스트 전용 container**여야 함
- Firebase 설정이 없으면 `initializeApp()`에서 런타임 오류 발생

---

# `let` vs `const`: 강의와 과제 코드에서의 차이

## ✅ 1. 질문 요지
> 강의에서는 `let`을 사용하는데, 왜 과제로 제공된 예제 파일에는 `const`가 사용되었는가?

---

## ✅ 2. 강의에서 `let`을 사용하는 이유

| 이유 | 설명 |
|------|------|
| 💡 개념 설명 중심 | `let`은 재할당 가능하므로 초보자에게 변수의 작동 방식을 보여주기 쉬움 |
| 🔄 실습 유연성 | `let`은 변수 값을 바꿔가며 테스트하기 좋음 |
| ❌ 불변성은 후순위 | 강의에서는 우선 “동작”하게 만드는 것이 중요함 |

### 예시:
```js
let title = $('#title').val();
title = "다른 제목"; // 실습에서 이런 식으로 바꿔보기 용이
```

---

## ✅ 3. 과제 코드에서 `const`를 사용하는 이유

| 이유 | 설명 |
|------|------|
| ✅ 불필요한 재할당 방지 | 값이 변하지 않아야 하는 상황에서 의도치 않은 변경 방지 |
| ✅ 코드 안정성 증가 | 실수로 값을 바꾸는 것을 방지함 |
| ✅ 의도 명확화 | 이 변수는 고정값이라는 것을 문법적으로 명시 |
| 📚 현업 베스트 프랙티스 | 실무에서는 기본적으로 `const`를 먼저 쓰고, 필요한 경우만 `let` 사용 |

### 예시:
```js
const db = getFirestore(app); // 절대 바뀌면 안 되는 고정된 설정
```

---

## ✅ 4. 언제 `let`, 언제 `const`?

| 상황 | `let` 사용 | `const` 사용 |
|------|------------|--------------|
| 값이 바뀔 가능성 있음 | ✅ | ❌ |
| 한 번 정의되면 고정됨 | ❌ | ✅ |
| 초보자 실습 단계 | ✅ | 사용 가능하나 let이 편함 |
| 실전 코드, 과제 제출 | ❌ | ✅ 보안성과 명확성 측면에서 유리 |

---

## ✅ 결론

> 강의에서는 실습 중심으로 변수 이해를 돕기 위해 `let`을 사용하고,  
> 과제나 실전 코드에서는 더 안정적이고 명확한 `const`를 사용하는 것이 일반적이다.

둘 다 맞는 사용법이지만, **"상황에 맞게 선택하는 것이 중요"** 하다.
