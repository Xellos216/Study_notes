# Day\_4\_QA.md

## ❓ Q1: 여기서 o는 그냥 임의로 정한 별칭일 뿐이고, sql 쿼리는 아니지?

**A1:** 맞다. `o`는 사용자가 `orders_v2` 테이블에 붙인 임의의 \*\*별칭(alias)\*\*일 뿐이고, SQL 문법 키워드는 아니다. 쿼리 안에서 테이블 이름 대신 짧게 부르기 위해 사용된다.

---

## ❓ Q2: 여기서 왜 name이 아니라 u.name인 거야?

**A2:** 여러 테이블을 조인할 경우, 같은 이름의 컬럼이 여러 테이블에 존재할 수 있다.
`u.name`처럼 **어느 테이블의 컬럼인지 명확히 지정하기 위해 별칭을 붙여 사용하는 것**이다.

---

## ❓ Q3: `FROM users u`도 users를 u 별칭으로 쓰겠다는 거야?

**A3:** 맞다. `FROM users u`는 `users` 테이블에 `u`라는 \*\*별칭(alias)\*\*을 부여하는 것이다. 이후 쿼리에서 `users.name` 대신 `u.name`처럼 간단히 쓸 수 있게 된다.

---

## ❓ Q4: `JOIN orders_v2 o ON u.id = o.user_id`에서 ON은 뭐야?

**A4:** `ON`은 **조인 조건**을 명시하는 절이다.
`u.id = o.user_id`는 `users` 테이블의 기본키(id)와 `orders_v2`의 외래키(user\_id)를 연결하여 조인하겠다는 의미다.

---

## ❓ Q5: SQL은 왜 읽는 순서(위→아래)와 실행 순서가 다른 거야?

**A5:** SQL은 **선언형(Declarative)** 언어이기 때문이다.

* Kotlin, Python 같은 절차형 언어는 순서대로 명령을 실행하지만,
* SQL은 \*\*“무엇을 얻고 싶은지”\*\*만 선언하면, 내부적으로 DB 엔진이 최적화된 순서로 실행한다.

▶ 예를 들어, SQL은 `SELECT → FROM → WHERE` 순으로 쓰이지만, 실제 실행 순서는 `FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT`이다.

이 구조는 사람이 읽고 이해하기 쉽게 설계된 것이며, DB는 실행 최적화를 위해 순서를 유연하게 해석한다.
